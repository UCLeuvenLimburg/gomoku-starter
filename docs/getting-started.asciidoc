// ROOT
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:important-caption: ‚ö†Ô∏è
:task-caption: üî®
:source-highlighter: pygments
:toc: left
:toclevels: 3
:experimental:
:nofooter:

= Getting Started

== Setting Up Visual Studio

[NOTE,caption={task-caption}]
====
* Open the Gomoku solution in Visual Studio by opening the solution file `Gomoku.sln`.
* Add a new "Class Library (.NET Core)" to the solution (in the Solution Explorer, right click on the solution at the root of the tree, choose Add &rarr; New Project). Name this project `ViewModel`.
* Add a new "WPF App (.NET Core)" to the solution. Name it `View`.
* In the Solution Explorer, right click on `View` and select Set as Startup Project.
====

If you press F5 (= run in debug mode), you should be greeted with an empty window.
Next, let's tell these freshly created projects which other projects they can depend upon.

[NOTE,caption={task-caption}]
====
* In the Solution Explorer, right click on Dependencies under ViewModel, pick add Project Dependencies and select Cells and Model. Definitely do *not* select View.
* Similarly, add the following dependencies to the View project: Cells, Model and ViewModel (i.e., all three).
====

This leads to the following dependency structure:

[.center,cols="^,^,^",width="40%"]
|===
3+| View
2+| ViewModel | WPF
| Model | Cell |
|===

where projects can only depend on things *below* them.
In other words:

* The ViewModel must be independent of WPF and the View.
* There are no restrictions imposed on the View: it sees all.

== Creating a Grid

During development, our first goal should be the produce visible results.
The sooner we can see that our code works, the better.
We do not want to have to first write dozens of lines of codes before being able to check their correctness.

In the case of Gomoku, a logical first step would be to visualize the board.
Unfortunately, this is also the most difficult step of the project.
However, this should not be a problem: this allows this guide to start off with giving you detailed information to help you get past this first obstacle.
The guide will then become less and less detailed as you progress.

=== ItemsControl

The game board is a grid with dimensions W &times; H (W columns, H rows).
Our goal is to visualize this as H rows of W buttons, each button corresponding to one square in the grid.

The easiest way to achieve this is to rely on ``ItemsControl``s.
An `ItemsControl` is a control that allows us to easily visualize lists, where we can specify how each item of the list should be visualized.
Since a grid is essentially a list of lists, we can use similarly nested ``ItemsControl``s to produce a visual grid.

* The top level `ItemsControl` receives a list of H rows.
* We need to tell this top level `ItemsControl` how to render these rows.
  We do this by having it create a new `ItemsControl` for each row.
* Each of these second level ``ItemsControl``s receives a list of W squares.

Let's build towards this structure step by step.
We start off by using an `ItemsControl` in the simplest possible way.

[NOTE,caption={task-caption}]
====
* In `MainWindow.xaml`, add an `ItemsControl` inside the `Grid.
* Give it a name using the `x:Name` property, e.g., `boardView`.
* In `MainWindow.xaml.cs`, create a `List<string>` with some strings in it:
+
[source,csharp]
----
var items = new List<string> { "a", "b", "c", "d", "e" };
----
* Assign this list to `boardView.ItemsSource`. This tells the `ItemsControl` which values it should show.
* Run the project (F5).

A window should appear showing the five strings one below the other.
====

=== ItemTemplate

Right now, the `ItemsControl` uses the default way to render the elements in its `ItemsSource`: it draws them as simple strings.
We would like to turn this into five buttons whose captions are these strings.
For this, we need to make use of the ``ItemsControl``'s `ItemTemplate` property.

[NOTE,caption={task-caption}]
====
* In `MainWindow.xaml`, set the `ItemTemplate` property as follows:
+
[source,diff]
----
  <ItemsControl x:Name="boardView">
+     <ItemsControl.ItemTemplate>
+         <DataTemplate>
+
+         </DataTemplate>
+     </ItemsControl.ItemTemplate>
  </ItemsControl>
----
* The `DataTemplate` represents how each element must be rendered.
  Place a `Button` in here.
+
[source,diff]
----
  <ItemsControl x:Name="boardView">
      <ItemsControl.ItemTemplate>
          <DataTemplate>
+             <Button />
          </DataTemplate>
      </ItemsControl.ItemTemplate>
  </ItemsControl>
----
* Run the code (F5).

A window with five very narrow buttons should appear.
====

The buttons' small height is due to the fact that we have not given them a label.
Let's rectify this:

[NOTE,caption={task-caption}]
====
* Give the `Button` a caption. Let's keep it simple for now and use `Click me`.
+
[source,diff]
----
  <ItemsControl x:Name="boardView">
      <ItemsControl.ItemTemplate>
          <DataTemplate>
-              <Button />
+              <Button Content="Click me" />
          </DataTemplate>
      </ItemsControl.ItemTemplate>
  </ItemsControl>
----
* Run your code (F5).

You should see five buttons, each labeled `Click me`.
====

Next, instead of labeling each button `Click me`, we want them to show the strings in the `ItemsSource`.

The `ItemsControl` instantiates the `ItemTemplate` for each of the elements in `ItemsSource`, in our case a `Button`.
It also sets the `DataContext` of each of these ``Button``s: the first `Button` will have `"a"` as `DataContext`, the second `"b"`, and so on.
In other words, each `Button` can rely on its `DataContext` to know which element it corresponds to.

[NOTE,caption={task-caption}]
====
Update the `Button`'s `Content` so that it shows the value of its `DataContext.

[source,diff]
----
  <ItemsControl x:Name="boardView">
      <ItemsControl.ItemTemplate>
          <DataTemplate>
-              <Button Content="Click me" />
+              <Button Content="{Binding .}" />
          </DataTemplate>
      </ItemsControl.ItemTemplate>
  </ItemsControl>
----

Here, `{Binding .}` means "use the `DataContext` itself".

Run your code. You should see five buttons, labeled `a`, `b`, `c`, `d` and `e`.
====

=== ItemsPanel

The buttons are laid out vertically.
In order to render the rows, we need them to be arranged horizontally instead.
Lucky for us, the `ItemsControl` has a property `ItemsPanel` which determines how the buttons will be positioned.

[NOTE,caption={task-caption}]
====
[source,diff]
----
  <ItemsControl x:Name="boardView">
      <ItemsControl.ItemTemplate>
          <DataTemplate>
              <Button Content="{Binding .}" />
          </DataTemplate>
      </ItemsControl.ItemTemplate>
+     <ItemsControl.ItemsPanel>
+         <ItemsPanelTemplate>
+             <StackPanel Orientation="Horizontal" />
+         </ItemsPanelTemplate>
+     </ItemsControl.ItemsPanel>
  </ItemsControl>
----

By default the `ItemsControl` uses a `StackPanel` with `Orientation="Vertical"`.
The above code changes this to a `StackPanel` with `Orientation="Horizontal"`.

Run your code.
The buttons should now be arranged horizontally instead of vertically.
====

=== Going 2D

We now have all ingredients to be able to show a grid.

[NOTE,caption={task-caption}]
====
Start with creating grid data in ``MainWindow``'s constructor in `MainWindow.xaml.cs`.

[source,csharp]
----
var row1 = new List<string> { "a", "b", "c", "d", "e" };
var row2 = new List<string> { "e", "f", "g", "h", "i" };
var row3 = new List<string> { "j", "k", "l", "m", "n" };
var grid = new List<List<string>> { row1, row2, row3 };

this.boardView.ItemsSource = grid;
----

If you run your code, you should see three horizontally arranged buttons.
Each `Button` has a `List<string>` as `DataContext`, which is also uses as `Content`.
Since WPF does not know how to render these, it decides to improve.
====

Now comes the tricky part: we need to visualize this grid.

[NOTE,caption={task-caption}]
====
* Go to `MainWindow.xaml`.
* Put your current `ItemsControl` in comments, so that you can reuse parts of it.
* Add code that creates a fresh `ItemsControl`.
  This will be the top level `ItemsControl` that's in charge of visualizing all rows.
  Remember that its `ItemsSource` is set to `grid`, i.e., a `List<List<string>>`.
* This top level `ItemsControl` should lay out its children *vertically*. Since this is the default, you do not need to specify a new `ItemsPanel`.
* Next, add code that sets its `ItemTemplate`.
* Inside this `ItemTemplate`, again create an `ItemsControl`. This one will be responsible to render a single row.
* Have this inner `ItemsPanel` arrange its items *horizontally*.
* Have its `ItemTemplate` be a `Button`.
* For now, set this ``Button``'s `Content` to simply `x`.
* Lastly, we must set the inner ``ItemControl``'s `ItemsSource`.
  We know that the outer `ItemsControl` has set its `DataContext` to a row, i.e., a `List<string>`.
  So, we should simply bind the inner ``ItemControl``'s `ItemsSource` to this `DataContext`: `ItemsSource={Binding .}`.

Run your code.
You should see a 3 rows of 5 buttons, all labeled `x`.
====

Instead of having every `Button` show `x`, we want them to show their corresponding letter.

[NOTE,caption={task-caption}]
====
Adjust the ``Button``'s `Content` so that it shows the correct letter instead of `x`.
Think of what each ``Button``'s `DataContext` is set to.
Remember that there are ways to find out what its value is if you're in doubt.
====

Each button has a different size, due to the letters having varying sizes.
For Gomoku, it'd be easier to play if each button had the same size.

[NOTE,caption={task-caption}]
====
Set the ``Button``'s `Width` and `Height` to `32`.
====

== IGame

Currently, we have defined our own grid data.
In this section, we will start relying on domain classes.
Let's explore these for a bit.

A game is by an object implementing the `IGame` interface.
This interface contains all Gomoku-related functionality.
To create a game, `IGame` offers a static factory method:

[source,csharp]
----
var game = IGame.Create(boardSize, capturing)
----

where

* `boardSize` is an `int` representing the size of the board;
* `capturing` is a `bool` determining whether or not capturing is enabled.

Right now, we are interested in the board.
We can access this using the `Board` property:

[source,csharp]
----
var board = game.Board;
----

It should not come as a surprise that this `board` contains all information related to the game board.

[source,csharp]
----
// Querying width
var width = board.Width;

// Querying height
var height = board.Height;

// Querying square
var position = new Vector2D(0, 0);
var stone = board[position];
----

Here, `stone` has type `Stone`.
A `Stone` can be one of three values:

* `Stone.BLACK` represents a black stone;
* `Stone.WHITE` represents a white stone;
* `null` represents a lack of stone.

In order for our `ItemsControl` construction to be able to work with this board, we need to restructure the data as a list of lists.

[NOTE,caption={task-caption}]
====
In `MainWindow.xaml.cs`, add the following methods to the `MainWindow` class:

* Write a method `IEnumerable<Stone> Row(IGameBoard board, int row)` that returns a `List<Stone>` containing all stones on the ``row``th row of `board`.
* Write a method `IEnumerable<IEnumerable<Stone>> Rows(IGameBoard board)` that calls `Row` for every row on `board` and returns the results as a list.
  In other words, this method returns a list of the rows of `board`.
* In the `MainWindow` constructor:
** Get rid of the old `List<List<string>>` related code.
** Create an `IGame` object with board size `5` (capturing does not matter).
** Use `Rows` to turn the ``IGame``'s `Board` into a `IEnumerable<IEnumerable<Stone>>`.
** Use this last result as the outer ``ItemsControl``'s `ItemsSource`.

Run your code.
You should see 5&times;5 buttons without label.
====

The missing label is due to the fact that initially, the board is empty.
In other words, the `IEnumerable<IEnumerable<Stone>>` is populated with nothing but `null` values.

== Drawing Stones

=== Placing Stones

Next, we want to visualize our stones.
For this, we need to first add stones to the game board.

[NOTE,caption={task-caption}]
====
In `MainWindow.xaml.cs`, use the game's `PutStone` method to add some stones, at least two to have both black and white stones.
Note that the `IGame` object is stateless, meaning you cannot modify it.
`PutStone` returns a *new* `IGame` object instead of modifying it.

Run your code.
If you did it correctly, you should see buttons containing `W` or `B`.
====

The `W` and `B` appear because we're asking WPF to draw `Stone` objects, but these are unknown to WPF.
In such cases, WPF chooses to call to `ToString()` method and render the result.
If you look at the implementation of `Stone`, you will see that the `ToString()` method does indeed return `B` or `W`, depending on the color of the stone.

=== Circles

Right now, we draw each square using

[source,xaml]
----
<Button Content="{Binding .}" Width="32" Height="32" />
----

In other words, we tell the `Button` that its contents are equal to its `DataContext`, which itself is equal to a `Stone`.
Given that WPF has no clue about how to draw ``Stone``s, we need to help it out a bit.

[NOTE,caption={task-caption}]
====
In `MainWindow.xaml`, change the button to

[source,xaml]
----
<Button Width="32" Height="32">
    <Ellipse Width="24" Height="24" Fill="Red" />
</Button>
----

Run the code.
Every button should now contain a small red circle.
====

=== StoneConverter

Next step is to have the ``Ellipse``'s `Fill` vary according to which stone is there:

[.center,cols="^,^",options="header",width="40%"]
|===
| Stone | Fill Brush
| `Stone.WHITE` | White
| `Stone.BLACK` | Black
| `null` | Transparent
|===

To convert from `Stone` to `Brush`, we need to create an `IValueConverter`.

[NOTE,caption={task-caption}]
====
* Add a new folder named `Converters` to your View project.
* Add a new class file named `StoneConverter.cs` to this folder.
* Have `StoneConverter` implement `IValueConverter`.
* In the `Convert` method
** The first parameter `value` corresponds to the stone.
   It has type `object`, but that's not a problem.
   We will be comparing references, meaning we don't need access to `Stone` specific functionality.
** If `value == Stone.BLACK`, return `Brushes.Black`.
** If `value == Stone.WHITE`, return `Brushes.White`.
** If `value == null`, return `Brushes.Transparent`.
====

We can now use this converter.

[NOTE,caption={task-caption}]
====
In `MainWindow.xaml`:

* We want to access `StoneConverter`, which resides in the `View.Converters` namespace.
  For this, we need to add an extra namespace mapping.
  Add the following attribute to `Window` (the top element):
+
[source,diff]
----
  <Window ...
          xmlns:local="clr-namespace:View"
+         xmlns:converters="clr-namespace:View.Converters"
          ...>
----
* Create the `StoneConverter` as a resource.
+
[source,diff]
----
  <Window ...>
+     <Window.Resources>
+         <converters:StoneConverter x:Key="stoneToBrushConverter" />
+     </Window.Resources>
      ...
  </Window>
----
* Bind `Fill` to the `DataContext` itself. Have it use `stoneToBrushConverter` as converter.

Run your code.
If you did everything correctly, you should see circles with the correct color.
====

=== Generalizing StoneConverter

Hardcoding the colors in `StoneConverter` is actually a bad idea:

* We can easily generalize it so that it becomes reusable.
* The color of the stones should be determined by an artist, not a programmer.
  Specifying the color in C# code is not very artist-friendly: they'd rather define everything in XAML.
* If we need more elaborate brushes, it's easier to define them in XAML than in C#.

So let us improve our `StoneConverter`.

[NOTE,caption={task-caption}]
====
In `StoneConverter`:

* Add three properties `White`, `Black` and `Empty`. Each has type `object` and has both a getter and setter.
* In the `Convert` method, return the values of `White`, `Black` and `Empty` instead of hardcoded brushes.

In `MainWindow.xaml`, initialize the three properties of the `StoneConverter`.
[source,diff]
----
  <Window ...>
      <Window.Resources>
-         <converters:StoneConverter x:Key="stoneToBrushConverter" />
+         <converters:StoneConverter x:Key="stoneToBrushConverter"
+                                    White="White"
+                                    Black="Black"
+                                    Empty="Transparent" />
      </Window.Resources>
      ...
  </Window>
----

Run your code and check that everything works as intended.
====

== Introducing ViewModels

As of yet, we have only written code in the View.
It is time we clean up our design and refactor a bit by moving things to the ViewModel layer.

ViewModel objects generally act as ``DataContext``s for GUI controls: they contain all information the control needs.
The goal of this approach is to build a layered structure:

* The ViewModel objects "passively" offers information through properties.
* The View will fetch this ViewModel data through bindings.

At no times should the ViewModel know anything about what exists on the View layer.

=== Unnaming the ItemsControl

The top level `ItemsControl` currently has a name: its `x:Name` property is set in the XAML code.
We needed this to be able to initialize its `ItemsSource` in the `MainWindow` constructor:

[source,csharp,highlight=10]
----
public MainWindow()
{
    InitializeComponent();

    var game = IGame.Create(5, true);

    game = game.PutStone(new Vector2D(0, 0));
    game = game.PutStone(new Vector2D(1, 0));

    this.boardView.ItemsSource = Rows(game.Board);
}
----

This approach is not ideal: it stands in our way of introducing ViewModels.
Instead, we would prefer that the control fetches its `ItemsSource` from its `DataContext` instead of us setting it explicitly in the code-behind.
Fortunately, this is easy to fix.

[NOTE,caption={task-caption}]
====
Instead of assigning the row data to ``boardView``'s `ItemsSource`, assign it to the ``MainWindow``'s `DataContext`.
The `ItemsControl` will then inherit its `DataContext` from `MainWindow`.

In the XAML file, remove the ``ItemsControl``'s name. Use a binding to set its `ItemsSource` to its `DataContext`.

Run the code to check that everything still works.
====

=== GameViewModel

As explained earlier, ``DataContext``s should be set to ViewModel objects.
Let's see what ``DataContext``s we have.

* The top level ``ItemsControl``'s `DataContext` is set to the grid data, i.e., an `IEnumerable<IEnumerable<Stone>>`.
* The inner ``ItemsControl``s each receive an `IEnumerable<Stone>` as `DataContext`.
* Each button has a single `Stone` as `DataContext`.

Let's wrap each of these in ViewModel objects, one at a time, starting with the top level `ItemsControl`.
Our current situation is

image::itemscontrol-directbinding.svg[Static,400,align="center"]

Our goal is to reorganize this as follows:

image::itemscontrol-gamevm.svg[Static,600,align="center"]

[NOTE,caption={task-caption}]
====
In The ViewModel, introduce a class `GameViewModel`.
We intend this class to contain all game related data.
For now, we will limit ourselves to have it expose the board so that the View can render its grid of buttons.

* Have the constructor accept an `IGame` object and have it stored in a private field.
* The top level `ItemsControl` needs rows, so introduce a public `Rows` property.
  It must have type `IEnumerable<IEnumerable<Stone>>`.
  It should be only gettable, not settable.
* You might want to bring along the `Row` helper method that extracts a single row from the board.

Next, update the `MainWindow` constructor.

* Keep the code that creates the `IGame` object and puts some stones around.
* Create a `GameViewModel` object and initialize it with the `IGame` object.
* Assign this `GameViewModel` object to the ``MainWindow``'s `DataContext`.
* Remove the `Row` and `Rows` methods from the `MainWindow` class, that functionality has been moved to `GameViewModel`.

Finally, in the XAML file, update the ``ItemsControl``'s `ItemsSource` binding.
It used to receive the rows directly as `DataContext`, but now they are stored inside a `GameViewModel`object's `Rows` property.

As always, run the code.
The same 5 &times; 5 grid of buttons should still appear.
====

=== GameBoardViewModel

Right now, the `GameViewModel` actually represents the board.
We would like to distinguish the game from its game board.
Let's create a separate `GameBoardViewModel` class.

image::itemscontrol-gamevm-boardvm.svg[Static,700,align="center"]

[NOTE,caption={task-caption}]
====
In the ViewModel, introduce a class `GameBoardViewModel`.

* The constructor expects a `IGameBoard` object, which it stores in a private field.
* Move the `Rows` property (and its helper methods, if any) from `GameViewModel` to `GameBoardViewModel`.

Update `GameViewModel`:

* Introduce a public property `Board` of type `GameBoardViewModel`, getter-only.
* Initialize this property in the constructor.

[IMPORTANT]
=====
Do not have the `Board` getter create a new `GameBoardViewModel` each time.
Make sure to create it only once, namely in the constructor, and have `Board` return it.
=====

Lastly, update the `ItemsSource` binding:

* It starts off in the `DataContext`, which is a `GameViewModel`.
* The binding needs to first go to its `Board` property.
* Next, it must dig deeper to the board's `Rows` property.

Run it and check that nothing has changed.
====

=== GameBoardRowViewModel

Next in line is a ViewModel representing a board row.

[NOTE,caption={task-caption}]
====
Introduce a class `GameBoardRowViewModel`.

* The constructor expects a `IEnumerable<Stone>`.
* The `IEnumerable<Stone>` is exposed through a property named `Elements`.
* Update the bindings of the inner ``ItemsControl``s.
  Their `DataContext` has now changed from `IEnumerable<Stone>` to `GameBoardRowViewModel`, so the binding will need to access the `Elements` property of its `DataContext`.

Run it and check that nothing has changed.
====

